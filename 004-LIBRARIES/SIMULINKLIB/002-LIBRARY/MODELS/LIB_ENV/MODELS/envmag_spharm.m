%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Calculate Local Magnetic Field based on a Spherical Harmonics Model
%
% Description:
%   Calculates the local magnetic field based on a spherical harmonics model.
%   Uses readmagcoeff to generate Gnm, Hnm, GnmDot, HnmDot, and  baseDate
%   parameters from data file generated by
%   http://www.ngdc.noaa.gov/IAGA/vmod/igrf.html
%
% Inputs:
%   date_years[1]                    Current gregorian year(years)
%   pos_BCBF[3]                      position in space where magnetic field
%                                    is observed in BCBF frame (m)
%   maxDegree[1]                     the maximum degree to consider when
%                                    calculating magnetic field (-)
%   re_cst[1]                        radius used to generate zonal,
%                                    tesseral and sectorial harmonics. (m)
%   Gnm[MAXDEGREE+1, MAXDEGREE+1]    zonal harmonic coefficients at a
%                                    given basedate
%   Hnm[MAXDEGREE+1, MAXDEGREE+1]    sectorial/tesseral harmonic
%                                    coefficients at a given basedate
%   GnmDot[MAXDEGREE+1, MAXDEGREE+1] rate of change of zonal harmonic
%                                    coefficients per year
%   HnmDot[MAXDEGREE+1, MAXDEGREE+1] rate of change of sectorial/tesseral
%                                    harmonic coefficients per year
%   basedate_years[1]                date for which Gnm and Hnm are most
%                                    valid for in decimal years
%                                    (e.g. 2013.0) it  should be <=
%                                    minimum value of MJD2000 when
%                                    converted to decimal years
%
% Outputs:
%   magfield_BCBF_T[3]               magnetic field vector expressed in
%                                    body centered body fixed frame (T)
%
% References:
%   Carlos M. Roithmayr, "Contributions of Spherical Harmonics to Magnetic
%   and Gravitational Fields," NASA Langley Research Center, Hampton,
%   Virginia, Technical Memorandum NASA/TMÿ2004ÿ213007, 2004.
%
% Modifications:
%  MA-20Jun16 initial draft
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [magfield_BCBF_T] = envmag_spharm(date_years, pos_BCBF, maxDegree, ...
                                           re_cst, Gnm, Hnm, GnmDot, ...
                                           HnmDot,  basedate_years)
  %#codegen
  % Pre declare outputs and check inputs that can effect compilation size
  magfield_BCBF_nT = zeros(size(pos_BCBF));
  
  % Adjust this to maximum degree available in coefficients file 
  assert(maxDegree <= 13);
  assert(size(Gnm, 1) >= maxDegree);
  
  % Get elements of position vector (in case user passes something weird in)
  rx_BCBF = pos_BCBF(1);
  ry_BCBF = pos_BCBF(2);
  rz_BCBF = pos_BCBF(3);
  
  % Determining geocentric Lat and Lon from pos vector
  rnorm = sqrt(rx_BCBF * rx_BCBF + ry_BCBF * ry_BCBF + rz_BCBF * rz_BCBF);
  
  % Rebuild unit vector to ensure its always a column vector
  runit = [rx_BCBF; ry_BCBF; rz_BCBF]/rnorm;
  slat  = (rz_BCBF/rnorm);
  
  % Solve for Anm,  Knm Sm and Cm tables
  Anm      = derivedLegend(maxDegree, slat);
  Knm      = KnmConstants(maxDegree);
  [Sm, Cm] = recursiveCmSm(maxDegree, rx_BCBF, ry_BCBF);
  
  % Pre-allocate/calculate re_cst^n
  a = zeros(maxDegree+3, 1);
  a(1)= 1;
  a(2)= re_cst;
  for i = 3:1:maxDegree+3
    a(i) = a(i-1) * re_cst;
  end
  
  % Pre-allocate/calculate rnorm^n
  R=zeros(maxDegree+maxDegree+2, 1);
  R(1)= 1;
  R(2)= rnorm;
  for i = 3:1:maxDegree + maxDegree + 2
    R(i) = R(i-1) * rnorm;
  end
  
  % Calculate gnm from Gnm and GmnDot
  % Should always be positive as baseDate should always be less than
  % currentdate
  dt_year = date_years - basedate_years;
  gnm     = Gnm + dt_year .*  GnmDot;
  hnm     = Hnm + dt_year .*  HnmDot;
  
  % Following method in P2/PV magnetic model
  e1 = zeros(maxDegree+1);
  e2 = zeros(maxDegree+1);
  e3 = zeros(maxDegree+1);
  r0 = zeros(maxDegree+1);
  
  % Compute magfield_BCBF_nT using Legendre polynomials
  for n = 1:1:maxDegree
    for m = 0:1:n
      % Add 1 for the tables as they originally assumed zero addressing in C-code
      factor = Knm(n+1, m+1) * a((n+2)+1) / R((n+m+1)+1);
      
      if m == 0
        e1(n+1, m+1) = 0.0;
        e2(n+1, m+1) = 0.0;
      else
        e1(n+1, m+1) = -factor * m * Anm(n+1, m+1) * (gnm(n+1, m+1) * Cm(m) + hnm(n+1, m+1) * Sm(m));
        e2(n+1, m+1) = -factor * m * Anm(n+1, m+1) * (hnm(n+1, m+1) * Cm(m) - gnm(n+1, m+1) * Sm(m));
      end
      
      factor       =  factor / rnorm * (gnm(n+1, m+1) * Cm(m+1) + hnm(n+1, m+1) * Sm(m+1));
      e3(n+1, m+1) = -factor * Anm(n+1, m+2);
      r0(n+1, m+1) =  factor * ( slat * Anm(n+1, m+2)  + (n+m+1) * Anm(n+1, m+1) );
      
      % Sum the magnetic field components together here
      magfield_BCBF_nT(1) = magfield_BCBF_nT(1) + e1(n+1, m+1) + r0(n+1, m+1) * runit(1);
      magfield_BCBF_nT(2) = magfield_BCBF_nT(2) + e2(n+1, m+1) + r0(n+1, m+1) * runit(2);
      magfield_BCBF_nT(3) = magfield_BCBF_nT(3) + e3(n+1, m+1) + r0(n+1, m+1) * runit(3);
    end
  end
  % Convert nT to T
  magfield_BCBF_T = magfield_BCBF_nT  * 1e-9;
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% derivedLegend
% Build  Derived Legendre polynomials (Anm) as per Ref document
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [Anm] = derivedLegend (nmax,  x)
  
  % Provide padding for m+1 operation (or m+2 if in matlab)
  Anm      =zeros(nmax+2);
  
  Anm(1, 1) = 1;
  Anm(1, 1) = 1;
  
  %/*---------------- Seed values ------------------*/
  Anm(1, 1) = 1.0;
  Anm(2, 2) = 1.0;
  for i = 1:1:nmax
    Anm(i+1, i+1) = (2 * i-1) *  Anm(i, i);
  end
  
  %/*--------- Calculate based on x ----------------*/
  Anm(2, 1) = x;
  for i = 2:1:nmax
    for j = 0:1:i-1
      Anm(i+1, j+1) = ((2 * i-1) * x * Anm(i, j+1) - (i+j-1) * Anm(i-1, j+1)) / (i-j);
    end
  end
  
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% KnmConstants
% Calculate Knm Constants associated with ref document
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [Knm] = KnmConstants(nmax)
  %   Provide padding for m+1 operation (or m+2 if in Matlab)
  Knm = zeros(nmax+2);
  
  for n = 1:1:nmax+1
    Knm(n, 1) = 1.0;
  end
  Knm(2, 2) = 1.0;
  
  for n = 2:1:nmax
    for m = 1:1:n
      if (n >= m+1)
        Knm(n+1, m+1) = sqrt((n-m)/(n+m))     * Knm(n, m+1);
      elseif (n >= m)
        Knm(n+1, m+1) = sqrt(1/(n+m)/(n-m+1)) * Knm(n+1, m);
      end
    end
  end
  
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% recursiveCmSm
% Calculate Sm and Cm arguments as defined in ref document
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [Sm, Cm]=recursiveCmSm(maxOrder, rx_BCBF, ry_BCBF)
  Sm = zeros(maxOrder + 1, 1);
  Cm = zeros(maxOrder + 1, 1);
  
  Sm(1) = 0;
  Cm(1) = 1;
  
  Sm(2) = ry_BCBF;
  Cm(2) = rx_BCBF;
  
  for i=3:1:maxOrder+1
    Sm(i) = Sm(2) * Cm(i-1) + Cm(2) * Sm(i-1);
    Cm(i) = Cm(2) * Cm(i-1) - Sm(2) * Sm(i-1);
  end
  
end
